#!/usr/bin/perl
# -*-perl-*-    vi: set ts=4 sw=4 :
#
#  Copyright (C) 2006-2007, vitki.net. All rights reserved.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  $Date$
#  $Revision$
#  $Source$
#
#  Editor of synaptic displays.
#

use strict;
use FindBin qw[$Bin];
use Cwd 'abs_path';
BEGIN { $ENV{OPTIKUS_HOME} = abs_path("$Bin/..") unless $ENV{OPTIKUS_HOME}; }
use lib "$ENV{OPTIKUS_HOME}/lib/perl5/site_perl";

use Gtk2;
use utf8;
use open ':utf8';

use Optikus::Canvas::Widget;
use Optikus::Canvas::Util;

#
#    Variables
#

my $temp = ".temp.osx";
my $screen_name;
my $changed = 0;

my ($fwin, $area, $statusbar, $scroll);
my ($attr_dialog, $widget_popup, $main_popup);

my ($bgim, $bgname, $grid);
my ($fwidth, $fheight);
my $DEBUG = 0;

my (%el_hash, @el_list);
my ($align_x, $align_y) = (1, 1);

my ($status_xy, $status_widget, $status_msg);
my ($selected_widget, $resized_widget);

my ($dragged_widget, $drag_x0, $drag_y0, $drag_xc, $drag_yc);
my ($last_press_time, $last_release_time, $last_motion_time);
my ($text_font, $text_color);

my ($cursor_normal, $cursor_resize, $cursor_move);

#
#    Menu
#

my @main_menu_items =
(
 [ "/_File",                   undef, undef, 0, "<Branch>" ],
 [ "/_File/_New",       "<control>N",  sub { clear_screen(); },            0  ],
 [ "/_File/_Open",      "<control>O",  sub { open_screen("?"); },          0  ],
 [ "/_File/_Save",      "<control>S",  sub { save_screen($screen_name); }, 0  ],
 [ "/_File/Save _as",   undef,         sub { save_screen("?"); },          0  ],
 [ "/_File/_Quit",      "<control>Q",  \&quit_editor,                    0  ],
 [ "/_Create",                    undef, undef, 0, "<Branch>" ],
 [ "/_Create/_Label",             undef, undef, 0, "<Branch>" ],
 [ "/_Create/_Label/_Label",      undef, sub { widget_new("Label"); },  0  ],
 [ "/_Create/_Label/_String",     undef, sub { widget_new("String"); }, 0  ],
 [ "/_Create/_Label/_Pixmap",     undef, sub { widget_new("Pixmap"); }, 0  ],
 [ "/_Create/_Label/_Bar",        undef, sub { widget_new("Bar"); }, 0  ],
 [ "/_Create/_Button",            undef, undef, 0, "<Branch>" ],
 [ "/_Create/_Button/_Button",    undef, sub { widget_new("Toggle::Button"); }, 0 ],
 [ "/_Create/_Button/_Switch",    undef, sub { widget_new("Toggle::Switch"); }, 0 ],
 [ "/_Create/_Button/_Anim",      undef, sub { widget_new("Anim"); }, 0 ],
 [ "/_Create/_Range",             undef, undef, 0, "<Branch>" ],
 [ "/_Create/_Range/_Ruler",      undef, sub { widget_new("Range::Ruler"); }, 0 ],
 [ "/_Create/_Range/_Dial",       undef, sub { widget_new("Range::Dial"); },  0 ],
 [ "/_Create/_Meter",             undef, undef, 0, "<Branch>" ],
 [ "/_Create/_Meter/_Big Tank",   undef, sub { widget_new("Meter::BigTank"); },   0 ],
 [ "/_Create/_Meter/_Small Tank", undef, sub { widget_new("Meter::SmallTank"); }, 0 ],
 [ "/_Create/_Meter/_Round Tank", undef, sub { widget_new("Meter::RoundTank"); }, 0 ],
 [ "/_Create/_Meter/_Thermometer",undef, sub { widget_new("Meter::ThermoMeter"); }, 0 ],
 [ "/_Create/_Meter/_Volume",     undef, sub { widget_new("Meter::Volume"); },    0 ],
 [ "/_Create/_Meter/_Manometer",  undef, sub { widget_new("ManoMeter"); },        0 ],
 [ "/_Create/_Meter/_Digital LED",undef, sub { widget_new("LED"); },              0 ],
 [ "/_Create/Cu_rve",             undef, undef, 0, "<Branch>" ],
 [ "/_Create/Cu_rve/_Curve",      undef, sub { widget_new("Curve"); }, 0 ],
 [ "/_Create/_Control", undef, undef, 0, "<Branch>" ],
 [ "/_Create/_Control/_Runner",      undef, sub { widget_new("Control::Runner"); }, 0 ],
 [ "/_Create/_Control/_Offnominal",  undef, sub { widget_new("Control::Offnominal"); }, 0 ],
 [ "/_Create/_Control/_Link",        undef, sub { widget_new("Control::Link"); }, 0 ],
 [ "/_Options", undef, undef, 0, "<Branch>" ],
 [ "/_Options/_Background image", undef, sub { bg_set($area, "?"); }, 0 ],
 [ "/_Options/Grid : _1",  undef, sub { set_snap(1, 1); }, 0 ],
 [ "/_Options/Grid : _4",  undef, sub { set_snap(4, 4); }, 0 ],
 [ "/_Options/Grid : _8",  undef, sub { set_snap(8, 8); }, 0 ],
 [ "/_Options/Grid : 1_6", undef, sub { set_snap(16, 16); }, 0 ],
 [ "/_Help", undef, undef, 0, "<LastBranch>" ],
 [ "/_Help/_About", undef, sub { print "Optikus Screen Editor\n"; }, 0 ]
);

#
#    Status Bar
#

sub update_status
{
  my $msg = "$status_xy | $status_widget | $status_msg";
  $statusbar->pop(1);
  $statusbar->push(1,$msg);
}

sub set_status_widget
{
  my $item = shift;
  $status_widget = "";
  return unless defined($item) or defined($selected_widget);
  if (not defined $item) {
    $status_widget .= "* ";
  } elsif ($item eq $selected_widget) {
    $status_widget .= "+ ";
  } else {
    $status_widget .= "- ";
  }
  $item = $selected_widget unless defined $item;
  my $clas = ref($item);
  $clas =~ s{^Optikus::Canvas::Widget::}{};
  $clas =~ s{::}{/};
  $status_widget .= "$clas ($item->{posx}x$item->{posy})";
  my $var = $item->{var};
  $status_widget .= " {$var}" if defined $var;
}

sub set_status_xy
{
  my ($x, $y, $item) = @_;
  $status_xy = sprintf("%-3d x %-3d", $x, $y);
  set_status_widget($item);
  update_status();
}

sub set_status_msg
{
  $status_msg = shift;
  update_status();
}

sub select_widget
{
  my $item = shift;
  set_status_widget($selected_widget = $item);
  update_status();
}

#
#    Main Window
#

sub create_screen
{
  my ($win, $tooltips, $accel_group, $item_factory,
      $winbox, $menubar, $tools, $tscroll);

  $win = Gtk2::Window->new("toplevel");
  $win->set_position("mouse");

  $tooltips = Gtk2::Tooltips->new;
  $win->{tooltips} = $tooltips;
  $winbox = Gtk2::VBox->new(0, 0);
  $win->add($winbox);

  $accel_group = Gtk2::AccelGroup->new;
  $win->add_accel_group($accel_group);
  $item_factory = Gtk2::ItemFactory->new('Gtk2::MenuBar', '<main>', $accel_group);
  $win->{"<main>"} = $item_factory;
  $item_factory->create_items(undef, @main_menu_items);
  $winbox->pack_start($item_factory->get_widget("<main>"), 0, 0, 0);

  $tools = Gtk2::Toolbar->new;
  $tools->set_style("icons");
  $tools->set_size_request(40,-1);
  $winbox->pack_start($tools, 0, 0, 0);
  create_tool($tools,"clear screen","kpic/filenew.png",
              sub { clear_screen(); });
  create_tool($tools,"open screen","kpic/fileopen.png",
              sub { open_screen("?"); });
  create_tool($tools,"save screen","kpic/filesave.png",
              sub { save_screen($screen_name); });
  create_tool($tools,"save screen as...","kpic/filesaveas.png",
              sub { save_screen("?"); });
  $tools->append_space;
  create_tool($tools,"edit item","kpic/edit.png",
              sub { widget_edit($selected_widget); });
  create_tool($tools,"copy item","kpic/editcopy.png",
              sub { widget_copy($selected_widget); });
  create_tool($tools,"delete item","kpic/editcut.png",
              sub { widget_delete($selected_widget,"confirm"); });
  $tools->append_space;
  create_tool($tools,"new label","kpic/frame_text.png",
              sub { widget_new("Label"); });
  create_tool($tools,"new switch","kpic/frame_chart.png",
              sub { widget_new("Toggle::Switch"); });
  create_tool($tools,"new string","kpic/frame_formula.png",
              sub { widget_new("String"); });
  create_tool($tools,"new picture","kpic/frame_image.png",
              sub { widget_new("Pixmap"); });
  $tools->append_space;
  create_tool($tools,"snap down","kpic/fontsizedown.png",
              sub { snap_change(-1); });
  create_tool($tools,"snap up","kpic/fontsizeup.png",
              sub { snap_change(1); });
  create_tool($tools,"bring to back","kpic/2downarrow.png",
              sub { widget_elevate($selected_widget,-1); });
  create_tool($tools,"bring to front","kpic/2uparrow.png",
              sub { widget_elevate($selected_widget,1); });
  create_tool($tools,"resize item","kpic/move.png",
              sub { start_resize($selected_widget); });
  create_tool($tools,"set background","kpic/imagegallery.png",
              sub { bg_set($area, "?"); });
  $tools->append_space;
  create_tool($tools, "quit editor", "kpic/exit.png", \&quit_editor);

  $scroll = Gtk2::ScrolledWindow->new;
  $winbox->pack_start($scroll, 1, 1, 1);
  $scroll->set_border_width(2);
  $scroll->set_policy("automatic", "automatic");
  $area = Gtk2::Fixed->new;
  $scroll->add_with_viewport($area);
  $grid = Gtk2::Image->new;
  $area->put($grid, 0, 0);
  my $ev = $area->parent;
  $ev->add_events([qw[button_press_mask pointer_motion_mask button_release_mask]]);
  $ev->signal_connect(button_press_event => \&button_press_handler, $area);
  $ev->signal_connect(button_release_event => \&button_release_handler, $area);
  $ev->signal_connect(motion_notify_event => \&motion_handler, $area);

  $statusbar = Gtk2::Statusbar->new;
  $winbox->pack_end($statusbar, 0, 0, 0);
  $win->show_all;
  set_snap(1, 1);

  return $win;
}

#
#    Mouse Operations
#

sub start_resize
{
  my $item = shift;
  return unless defined $item;
  $area->window->set_cursor($cursor_resize);
  $resized_widget = $item;
  $item->{save_width} = $item->{WIDGET}->allocation->width;
  $item->{save_height} = $item->{WIDGET}->allocation->height;
}

sub button_press_handler
{
  my ($widget, $event, $param) = @_;
  return 0 if $event->time == $last_press_time;
  $last_press_time = $event->time;
  my $item = find_widget_by_xy($event->x, $event->y, $widget,
                               $area->parent, @el_list);
  close_popups();
  if (defined $resized_widget)
  {
    $resized_widget->resize($resized_widget->{save_width},
                        $resized_widget->{save_height},
                        $resized_widget->{posx},
                        $resized_widget->{posy})
	if $event->button == 3;
    undef $resized_widget->{save_width};
    undef $resized_widget->{save_height};
    undef $resized_widget;
    return;
  }
  unless (defined $item)
  {
    select_widget(undef);
    if ($event->button == 3)  {
      create_main_popup();
      return 1;
    }
    return 0;
  }
  if ($event->button == 1)
  {
    $dragged_widget = $item;
    my ($t_w, $x, $y, $t_m) = Gtk2::Gdk->get_default_root_window->get_pointer;
    ($drag_x0, $drag_y0) = ($x, $y);
    ($drag_xc, $drag_yc) = ($item->{posx}, $item->{posy});
    $item->{WIDGET}->set_state("prelight");
    select_widget($item);
    $area->window->set_cursor($cursor_move);
    return 1;
  }
  if ($event->button == 3) {
    select_widget(undef);
    widget_menu($item);
    return 1;
  }
  return 0;
}

sub widget_drag
{
  my $widget = $dragged_widget->{WIDGET};
  my ($t_w, $cx, $cy, $t_m) =
      Gtk2::Gdk->get_default_root_window->get_pointer;
  my $nx = $drag_xc + $cx - $drag_x0;
  my $ny = $drag_yc + $cy - $drag_y0;
  ($nx, $ny) = snap_xy($nx, $ny);
  unless ($nx == $dragged_widget->{posx} and $ny == $dragged_widget->{posy}) {
    $widget->parent->move($widget,$nx,$ny);
    ($dragged_widget->{posx}, $dragged_widget->{posy}) = ($nx, $ny);
  }
  return $widget;
}

sub button_release_handler
{
  my ($widget, $event, $param) = @_;
  return 0 if $event->time == $last_release_time;
  $last_release_time = $event->time;
  if (defined $dragged_widget)
  {
    widget_drag()->set_state("normal");
    $changed = 1;
  }
  if (defined $resized_widget)
  {
    $changed = 1;
  }
  $area->window->set_cursor($cursor_normal);
  undef $dragged_widget;
  undef $resized_widget;
}

sub motion_handler
{
  my ($widget, $event, $param) = @_;
  return 0 if $event->time == $last_motion_time;
  $last_motion_time = $event->time;
  my ($x, $y) = recalc_xy($event->x, $event->y, $widget, $area->parent);
  my $item = find_widget_by_xy($event->x, $event->y, $widget,
                               $area->parent, @el_list);
  #print "status $widget ($x x $y) $item\n";
  set_status_xy($x, $y, $item);
  #print STDERR "+";
  if (defined $dragged_widget)
  {
    widget_drag;
  }
  if (defined $resized_widget)
  {
    my $widget = $resized_widget->{WIDGET};
    my $nw = $x - $resized_widget->{posx};
    my $nh = $y - $resized_widget->{posy};
    ($nw, $nh) = snap_xy($nw, $nh);
    my $widget = $resized_widget->{WIDGET};
    unless ($resized_widget->resize($nw, $nh,
                                    $resized_widget->{posx},
                                    $resized_widget->{posy}))
    {
      print "resize rejected\n";
      undef $resized_widget;
      close_popups();
    }
  }
  return 0;
}

#
#    Window
#

sub bg_set
{
  my ($area, $name) = @_;
  if ($name eq "?") {
    create_file_sel("bg", "Select background image",
                    (defined $bgname ? "$pic_home/$bgname" : $pic_home),
                    sub { bg_set($area, shift); });
    return;
  }
  my $rcstyle = Gtk2::RcStyle->new;
  if (defined $name) {
    $bgname = $name;
    $name = "$pic_home/$name" unless $name =~ m[^/];
    $bgname =~ s[^$pic_home/][];
  } else {
    undef $bgname;
  }
  $rcstyle->bg_pixmap_name("normal", $name);
  $area->parent->modify_style($rcstyle) if defined $area;
  foreach my $item (@el_list) {
    next unless $item->{want_bg};
    $item->{WIDGET}->modify_style($rcstyle);
  }
  bg_refresh();
  $changed = 1;
}

sub bg_refresh
{
  snap_change(0) if $grid->visible;
}

sub snap_change
{
  my $dir = shift;
  if ($dir > 0) {
    set_snap($align_x*2,$align_y*2);
  } elsif ($dir < 0) {
    set_snap($align_x/2,$align_y/2);
  } else {
    set_snap($align_x,$align_y);
  }
}

sub set_snap
{
  ($align_x, $align_y) = @_;
  $align_x = 2 if $align_x < 2;
  $align_y = 2 if $align_y < 2;
  if ($align_x <= 4 or $align_y <= 4)  {
    $grid->hide;
    return;
  }
  my $w = $area->parent->allocation->width - 4;
  my $h = $area->parent->allocation->height - 4;
  my $canvas = Gtk2::Gdk::Pixmap->new($area->window, $w, $h, -1);
  my $gc = Gtk2::Gdk::GC->new($canvas, undef);
  my $bg = $area->parent->style->bg_pixmap("normal");
  if (defined $bg) {
    my ($step_x, $step_y) = $bg->get_size;
    for (my $x = 0; $x < $w; $x += $step_x) {
      for (my $y = 0; $y < $h; $y += $step_y) {
        $canvas->draw_drawable($gc, $bg, 0,0, $x,$y,$step_x,$step_y);
      }
    }
  } else {
    my $bg_gc = $area->parent->style->bg_gc("normal");
    $canvas->draw_rectangle($bg_gc, 1, 0, 0, $w, $h);
  }
  my @c_list = ("#ffffff", "#333333");
  $gc->set_line_attributes (0, "on-off-dash", "round","miter");
  for my $off (0 .. $#c_list) {
    my $c = Gtk2::Gdk::Color->parse($c_list[$off]);
    $gc->get_colormap->alloc_color($c,0,0);
    $gc->set_foreground($c);
    my ($x, $y, $d);
    $d = int($align_x / 3) + 1;
    $gc->set_dashes(0, $d, $align_y - $d);
    for ($x = $off; $x < $w; $x += $align_x) {
      $canvas->draw_line($gc, $x, $0, $x, $h);
    }
    $d = int($align_y / 3) + 1;
    $gc->set_dashes(0, $d, $align_x - $d);
    for ($y = $off; $y < $h; $y += $align_y) {
      $canvas->draw_line($gc, $0, $y, $w, $y);
    }
    $gc->get_colormap->free_colors($c);
  }
  $grid->set_from_pixmap($canvas, undef);
  $grid->show;
}

sub snap_xy
{
  my ($x, $y) = @_;
  
  my $rx = $x % $align_x;
  my $ry = $y % $align_y;

  if ($rx < $align_x / 2) {
    $x -= $rx;
  } else {
    $x += ($align_x - $rx);
  }
  if ($ry < $align_y / 2) {
    $y -= $ry;
  } else {
    $y += ($align_y - $ry);
  }
  return ($x, $y);
}

sub align_all
{
  my ($gx, $gy) = @_;
  print "in align_all($gx, $gy)\n";
  $area->hide;
  for my $item (@el_list)
  {
    my $w = $item->{WIDGET};
    my $x = $item->{posx};
    my $y = $item->{posy};
    print "\t ($x, $y) -> ";
    $area->move($item->{WIDGET}, 0, 0);

    my $rx = $x % $gx;
    my $ry = $y % $gy;

    if ($rx < $gx / 2) {
      $x -= $rx;
    } else {
      $x += ($gx - $rx)
	};
    if ($ry < $gy / 2) {
      $y -= $ry;
    } else {
      $y += ($gy - $ry);
    };
    $item->{posx} = $x;	
    $item->{posy} = $y;	
  };	
  $area->show_all;
  $changed = 1;
}

sub close_popups
{
  $main_popup->destroy if defined $main_popup;
  undef $main_popup;
  $widget_popup->destroy if defined $widget_popup;
  undef $widget_popup;
  $area->window->set_cursor($cursor_normal)
      if defined $area and defined $area->window;
}

sub create_main_popup
{
  close_popups;
  $main_popup = Gtk2::Window->new("popup");
  my ($t_w, $cx, $cy, $t_m) = Gtk2::Gdk->get_default_root_window->get_pointer;
  $main_popup->move($cx-20, $cy-8);
  my $hbox = new Gtk2::VBox(0, 0);
  $main_popup->add($hbox);
  my $b;
  $hbox->pack_start($b = Gtk2::Button->new("text font"), 0, 1, 0);
  $b->signal_connect('clicked', sub { close_popups; set_text_font(); });
  $hbox->pack_start($b = Gtk2::Button->new("text color"), 0, 1, 0);
  $b->signal_connect('clicked', sub { close_popups; set_text_color(); });
  $hbox->pack_start($b = Gtk2::Button->new("bg image"), 0, 1, 0);
  $b->signal_connect('clicked', sub { close_popups; bg_set($area,"?"); });
  $hbox->pack_start(Gtk2::VSeparator->new, 0, 1, 0);
  $hbox->pack_start($b = new Gtk2::Button("grid : 1"), 0, 1, 0);
  $b->signal_connect('clicked', sub { close_popups; set_snap(1, 1); });
  $hbox->pack_start($b = Gtk2::Button->new("grid : 4"), 0, 1, 0);
  $b->signal_connect('clicked', sub { close_popups; set_snap(4, 4); });
  $hbox->pack_start($b = Gtk2::Button->new("grid : 8"), 0, 1, 0);
  $b->signal_connect('clicked', sub { close_popups; set_snap(8, 8); });
  $hbox->pack_start($b = Gtk2::Button->new("grid : 16"), 0, 1, 0);
  $b->signal_connect('clicked', sub { close_popups; set_snap(16, 16); });
  $hbox->pack_start(Gtk2::VSeparator->new, 0, 1, 0);
  $hbox->pack_start($b = Gtk2::Button->new("cancel"), 0, 1, 0);
  $b->signal_connect('clicked', sub { close_popups; });
  $main_popup->show_all;
}

sub set_text_font
{
  create_font_sel(undef, $text_font, sub {
    $text_font = shift;
    for my $item (@el_list) {
      $item->update_appearance(0, font => $text_font, color => $text_color);
    }
  });
}

sub set_text_color
{
  create_color_sel(undef, $text_color, sub {
    $text_color = shift;
    for my $item (@el_list) {
      $item->update_appearance(0, font => $text_font, color => $text_color);
    }
  });
}

#
#    Widget Operations
#

sub widget_new
{
  my $clas = shift;
  my $clas = "Optikus::Canvas::Widget::". $clas;
  my @attr = $clas->get_attr_list;
  edit_attr_list($clas, \@attr, sub {
    my $attr = shift;
    $attr->{_parent} = $area;
    $attr->{_window} = $fwin;
    $attr->{_cantfocus} = "TRUE";
    widget_create($clas, %$attr);
  });
}

sub widget_delete
{
  my ($item, $confirm) = @_;
  return unless defined $item;
  if (length($confirm) > 0) {
    run_dialog("Confirm deletion", "Are you sure to delete item ?",
               sub { widget_delete($item); });
    return;
  }
  #print "deleting $item\n";
  delete $el_hash{$item};
  undef $el_hash{$item};
  for my $i (0.. $#el_list) {
    if ($item eq $el_list[$i]) {
      splice @el_list, $i, 1;
      last;
    }
  }
  $item->{WIDGET}->destroy;
  $changed = 1;
  return 1;
}

sub widget_edit
{
  my $item = shift;
  return unless defined $item;
  my $clas = ref $item;
  my @attrlist = $item->get_attr_list;
  for my $a (@attrlist) { $a->{value} = $item->{$a->{attr}};  }
  my %_attr = ();
  for my $a (keys %$item) { $_attr{$a} = $item->{$a} if /^_/; };
  edit_attr_list($clas, \@attrlist, sub {
    my $attr = shift;
    widget_delete($item);
    for my $a (keys(%_attr)) { $attr->{$a} = $_attr{$a}; }
    widget_create($clas, %$attr);
  });
}

sub widget_copy
{
  my $item = shift;
  return unless defined $item;
  my $clas = ref $item;
  my @attrlist = $item->get_attr_list;
  for my $a (@attrlist) {
    $a->{value} = $item->{$a->{attr}};
    $a->{value} += 20 if $a->{attr} eq "posx" or $a->{attr} eq "posy";
  }
  my %_attr = ();
  for my $a (keys %$item) { $_attr{$a} = $item->{$a} if /^_/; };
  edit_attr_list($clas, \@attrlist, sub {
    my $attr = shift;
    for my $a (keys(%_attr)) { $attr->{$a} = $_attr{$a}; }
    widget_create($clas, %$attr);
  });
}

sub widget_create
{
  my ($clas, %attr) = @_;
  $attr{_window} = $fwin;
  $attr{_area} = $area;
  my $item = new $clas(%attr);
  my $widget = $item->{WIDGET};
  return unless defined $item and defined $widget;
  $el_hash{$item} = $item;
  unshift @el_list, $item;
  $item->{posx} = 10 unless defined $item->{posx};
  $item->{posy} = 10 unless defined $item->{posy};
  $area->put($widget, $item->{posx}, $item->{posy});
  $widget->realize;
  $widget->show_all;
  if (defined($text_font) or defined($text_color)) {
    $item->update_appearance (0, font => $text_font, color => $text_color);
  }
  $widget->can_focus(0);
  $widget->add_events([qw[button_press_mask pointer_motion_mask button_release_mask]]);
  $widget->signal_connect(button_press_event => \&button_press_handler, $item);
  $widget->signal_connect(button_release_event => \&button_release_handler, $item);
  $widget->signal_connect(motion_notify_event => \&motion_handler, $item);
  $changed = 1;
}

sub widget_elevate
{
  my ($item, $dir) = @_;
  return unless defined $item;
  my $widget = $item->{WIDGET};
  return if $dir == 0;
  return if $dir > 0 and $item eq $el_list[0];
  return if $dir < 0 and $item eq $el_list[$#el_list];
  $area->hide;
  for my $i (0 .. $#el_list) {
    if ($item eq $el_list[$i]) {
      splice @el_list, $i, 1;
      last;
    }
  }
  if ($dir > 0) {
    $area->remove($widget);
    $area->put($widget, $item->{posx}, $item->{posy});
    unshift @el_list, $item;
  } else {
    $area->remove($widget);
    my @list;
    for my $child ($area->get_children) {
      next if $child eq $grid;
      push @list, [ $child,
                    $child->allocation->x, $child->allocation->y ];
    }
    $area->put($widget, $item->{posx}, $item->{posy});
    for my $item (@list) {
      $area->remove($item->[0]);
    }
    for my $item (@list) {
      $area->put($item->[0], $item->[1], $item->[2]);
    }
    push @el_list, $item;
  }
  $area->show_all;
}

#
#    Attributes
#

sub edit_attr_list
{
  my ($clas, $attrlr, $coderef) = @_;
  my ($label, $entry, $hbox, $vbox, $vbox1, $frame,
      $hbox, $hbox1, $button, $ok, $cancel);

  my %entry = ();
  my %attr = ();
  
  $attr_dialog->destroy() if defined $attr_dialog;
  $attr_dialog = Gtk2::Window->new("toplevel");
  $attr_dialog->set_title("Properties: $clas");
  $attr_dialog->set_position("mouse");

  $vbox = new Gtk2::VBox(0,5);
  $attr_dialog->add($vbox);
  $frame = Gtk2::Frame->new($clas);
  $vbox->add($frame);

  $vbox1 = new Gtk2::VBox(0,2);
  $frame->add($vbox1);

  for my $a (@$attrlr)
  {
    undef $button;
    $hbox = new Gtk2::HBox(0,5);
    my $type = $a->{type};
    $type = "int" if not defined $type;
    $label = new Gtk2::Label($a->{attr}."(" .$type.")");
    $label->set_alignment(1, 0);
    my $entry = Gtk2::Entry->new;
    $entry->set_size_request(400, 25);
    $hbox->pack_start($label, 1, 1, 0);
    if ($type eq "image" or $type eq "images" or $type eq "glabel")
    {
      $button = create_hor_button("pic(kpic/folder.png)");
      $button->set_relief("none");
      $button->can_default(0);
      $hbox->pack_start($button, 0, 0, 0);
      my $file_name = $pic_home . "/" . $entry->get_text;
      $button->signal_connect(clicked => sub {
        create_file_sel("image", "Choose image", $file_name, sub {
          my $file = shift;
          $file =~ s{^$pic_home/}{};
          my $text = $entry->get_text();
          $text = "" if $type eq "image";
          if ($type eq "glabel") {
            $text .= "\\n pic($file) \\n";
          } else {
            $text .= "," if length($text) > 0;
            $text .= $file;
          }
          $entry->set_text($text);
        });
      });
    }
    if ($type eq "font")
    {
      $button = create_hor_button("pic(kpic/folder.png)");
      $button->set_relief("none");
      $button->can_default(0);
      $hbox->pack_start($button, 0, 0, 0);
      $button->signal_connect(clicked => sub {
        create_font_sel(undef, $entry->get_text, sub {
          my $font = shift;
          $entry->set_text($font);
        });
      });
    }
    if ($type eq "color")
    {
      $button = create_hor_button("pic(kpic/folder.png)");
      $button->set_relief("none");
      $button->can_default(0);
      $hbox->pack_start($button, 0, 0, 0);
      $button->signal_connect(clicked => sub {
        create_color_sel(undef, $entry->get_text, sub {
          my $color = shift;
          $entry->set_text($color);
        });
      });
    }
    $hbox->pack_end($entry, 0, 1, 0);
    $vbox1->pack_start($hbox, 0, 1, 2);
    $entry->set_text($a->{value}) if defined $a->{value};
    $entry{$a->{attr}} = $entry;
  }
  $hbox = Gtk2::HBox->new(0,1);
  $vbox->pack_end($hbox, 0, 1, 1);
  $ok = new Gtk2::Button("OK");
  $hbox->pack_start($ok, 1, 1, 1);
  $ok->signal_connect("clicked", sub {
    while (my($k, $v) = each %entry) { $attr{$k} = $v->get_text; }
    &$coderef(\%attr);
    $attr_dialog->destroy;
  });
  $cancel = new Gtk2::Button("Cancel");
  $cancel->can_default(0);
  $hbox->pack_end($cancel, 1, 1, 1);
  $cancel->signal_connect(clicked => sub {$attr_dialog->destroy();} );
  $attr_dialog->show_all;
  $ok->can_default(1);
  $ok->has_default(1);
  #$ok->grab_default();
  #$ok->has_focus(1);
}

sub widget_menu
{
  my $item = shift;
  close_popups;
  $widget_popup = Gtk2::Window->new("popup");
  my ($t_w, $cx, $cy, $t_m) = Gtk2::Gdk->get_default_root_window->get_pointer;
  $widget_popup->move($cx, $cy);
  my $hbox = Gtk2::VBox->new(0, 0);
  $widget_popup->add($hbox);
  my $b;
  $hbox->pack_start($b = Gtk2::Button->new("Edit"), 0, 1, 0);
  $b->signal_connect(clicked => sub { close_popups; widget_edit($item); }) ;
  $hbox->pack_start($b = Gtk2::Button->new("Copy"), 0, 1, 0);
  $b->signal_connect(clicked => sub { close_popups; widget_copy($item); }) ;
  $hbox->pack_start($b = Gtk2::Button->new("Delete"), 0, 1, 0);
  $b->signal_connect(clicked => sub { close_popups; widget_delete($item); } );
  $hbox->pack_start($b = Gtk2::Button->new("Resize"), 0, 1, 0);
  $b->signal_connect(clicked => sub { close_popups; start_resize($item); } );
  $hbox->pack_start($b = Gtk2::Button->new("Cancel"), 0, 1, 0);
  $b->signal_connect(clicked => sub { close_popups; });
  $widget_popup->show_all;
}

#
#  Saving and Restoring
#

sub quit_editor
{
  if ($changed) {
    confirm_saving(sub{ $changed=0; quit_editor(); });
    return;
  }
  print "OK\n";
  Gtk2->main_quit;
}

sub clear_screen
{
  if ($changed) {
    confirm_saving(sub { $changed=0; clear_screen(); });
    return;
  }
  close_popups();
  undef $resized_widget;
  undef $selected_widget;
  $status_xy = $status_widget = $status_msg = "";
  update_status();
  bg_set($area, undef);
  for my $item (@el_list) { $item->{WIDGET}->destroy; }
  @el_list = ();
  %el_hash = ();
  set_screen_name("noname.osx");
  $changed = 0;
}

sub confirm_saving
{
  my $func = shift;
  return unless $changed;
  run_dialog("Confirm deletion",
             "There are unsaved changes.\nAre you sure ?",
             $func);
}

sub open_screen
{
  my $file = shift;
  if ($changed) {
    confirm_saving(sub { $changed=0; open_screen($file); });
    return;
  }
  $file = "noname.osx" unless defined $file;
  if ($file eq "?") {
    create_file_sel("open", "Open screen...", $scr_home,
                     \&open_screen);
    return;
  }
  clear_screen();
  unless (-r $file) {
    print "cannot read $file\n";
    undef $fwidth;
    undef $fheight;
  }
  else {
    print "reading $file...\n";
    parse_simple_xml($file, undef, \&handle_xml_elem);
  }
  $fwidth = 640 unless defined $fwidth;
  $fheight = 480 unless defined $fheight;
  my ($wx, $wy, $ww, $wh, $wd) = $fwin->window->get_geometry;
  my $rw = $fwidth + $ww - $scroll->allocation->width;
  my $rh = $fheight + $wh - $scroll->allocation->height;
  $fwin->hide;
  $fwin->set_gravity("center");
  $fwin->set_position("center");
  $fwin->set_default_size($rw, $rh);
  $fwin->resize($rw, $rh);
  $fwin->show;
  set_screen_name($file);
  bg_set($area, $bgname);
  $changed = 0;
  print "opened [$file] ${fwidth}x${fheight}\n";
}

sub handle_xml_elem
{
  my ($file, $screen, $tag, $attr) = @_;
  return 0 unless $tag eq "widget" or $tag eq "window";
  my %attr = %{$attr};
  if ($tag eq "widget")
  {
    $attr{class} = "" unless defined $attr{class};
    $attr{type} = "" unless defined $attr{type};
    my $clas = join("::", "Optikus", "Canvas", "Widget", $attr{class}, $attr{type});
    $clas =~ s/:+$//;
    $attr{_parent} = $area;
    $attr{_window} = $fwin;
    $attr{_screen} = $screen;
    widget_create($clas, %attr);
  }
  if ($tag eq "window")
  {
    $bgname = $attr{background};
    $fwidth = $attr{width};
    $fheight = $attr{height};
    $text_font = $attr{textfont};
    $text_color = $attr{textcolor};
    bg_set($area, $bgname);
  }
  return 1;
}

sub save_screen
{
  my $file = shift;
  $file = $screen_name unless defined $file;
  $file = "?" if $file =~ /^noname/;
  if ($file eq "?") {
    create_file_sel("save_as","Save screen as...", $scr_home, \&save_screen);
    return;
  }
  unless (open F, ">$temp") {
    Gtk->print("cannot open [$temp] for writing");
    return;
  }
  print F "<?xml version=\"1.0\"?>\n";
  print F "<screen>\n <window>\n";
  my ($w, $h) = ($scroll->allocation->width, $scroll->allocation->height);
  print F "  <width>$w</width>\n  <height>$h</height>\n";
  print F "  <background>$bgname</background>\n" if defined $bgname;
  print F "  <textfont>$text_font</textfont>\n" if defined $text_font;
  print F "  <textcolor>$text_color</textcolor>\n" if defined $text_color;
  print F " </window>\n <widgets>\n";
  for my $item (reverse @el_list) {
    my $class = ref($item);
    $class =~ s/^Optikus::Canvas::Widget:://;
    print F "  <widget>\n";
    print F "   <class>$class</class>\n";
    my @attr = $item->get_attr_list;
    foreach my $a (@attr) {
      my $attr = $a->{attr};
      my $value = $item->{$attr};
      next unless defined $value and length($value) > 0;
      $value =~ s/\&/\&amp\;/g;
      $value =~ s/\</\&lt\;/g;
      $value =~ s/\>/\&gt\;/g;
      $value =~ s/\"/\&quot\;/g;
      print F "   <$attr>$value</$attr>\n";
    }
    print F "  </widget>\n";
  }
  print F " </widgets>\n</screen>\n";
  unless (close F) {
    print "error while closing temp file $temp";
    return;
  }
  #rename $file, "$file.bak";
  #rename $temp, $file;
  system("mv -f $file $file.bak 2>/dev/null; mv -f $temp $file 2>/dev/null");
  set_screen_name($file);
  $changed = 0;
  print "saved [$file]\n";
}

sub set_screen_name
{
  my $name = shift;
  $screen_name = $name;
  $name =~ s{^.*\/}{};
  $fwin->set_title("Optikus Display Editor [$name]");
}

sub dump_widget
{
  my ($item, $msg) = @_;
  my $clas = ref $item;
  $clas =~ s{Optikus::Canvas::Widget::}{};
  $clas =~ s{::}{/};
  print "$msg: $clas ($item->{posx} x $item->{posy})";
  my $g = $item->{WIDGET};
  if (defined $g) {
    my ($x, $y) = ($g->allocation->x, $g->allocation->y);
    my ($w, $h) = ($g->allocation->width, $g->allocation->height);
    print " $g ($x x $y) [$w x $h]";
  }
  print "\n";
}

sub dump_list
{
  my $i = 0;
  print "================\n";
  for my $item (@el_list) { dump_widget($item, ++$i); }
  print "================\n";
}

#
#    main procedure
#

pforms_gtk_init("opedit");
$Optikus::Canvas::Widget::SIMULATION = 1;
$cursor_normal = Gtk2::Gdk::Cursor->new("left-ptr");
$cursor_resize = Gtk2::Gdk::Cursor->new("lr-angle");
$cursor_move   = Gtk2::Gdk::Cursor->new("fleur");
$fwin = create_screen();
Optikus::Canvas::Util::set_window_icon($fwin, "kpic/colorize.png");
$changed =0;
open_screen($ARGV[0]);
$fwin->signal_connect(destroy  => \&quit_editor);
$scroll->signal_connect(size_allocate => \&bg_refresh);
Gtk2->main;

