#!/usr/bin/perl
# -*-perl-*-    vi: set ts=4 sw=4 :
#
#  Copyright (C) 2006-2007, vitki.net. All rights reserved.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  $Date$
#  $Revision$
#  $Source$
#
#  Controls target via packet interface.
#

use strict;
use FindBin qw[$Bin];
use Cwd 'abs_path';
BEGIN { $ENV{OPTIKUS_HOME} = abs_path("$Bin/..") unless $ENV{OPTIKUS_HOME}; }
use lib "$ENV{OPTIKUS_HOME}/lib/perl5/site_perl";

use utf8;
use open ':utf8';
use Carp;
use Gtk2;
use Data::Dumper;
use Optikus::Canvas::Util;
use Optikus::Log ':all';
use Optikus::Watch;


my $cmsg_list_file = "$etc_home/cmsg.lst";
my $param_hash_file = "$etc_home/cmsg.hash";

our @cmsg;
our %cmsg_class;
our %rparam;

my (%cmsg_hash, $cmsg_tree, $cmsg_model);
my ($target, $func, $data);

my $not_saved = 1;

my %param_type = (
          'c' => { display => 'char',   pattern => '%c'  },
		  'C' => { display => 'uchar',  pattern => '%c'  },
		  'h' => { display => 'short',  pattern => '%hd' },
		  'H' => { display => 'ushort', pattern => '%hu' },
		  'l' => { display => 'long',   pattern => '%ld' },
		  'L' => { display => 'ulong',  pattern => '%lu' },
		  'f' => { display => 'float',  pattern => '%f'  },
		  'd' => { display => 'double', pattern => '%lf' },
		 );

my %TARGET = ('SIM'=>'sim', 'sim'=>'sim', 'SAMPLE'=>'sample', 'sample'=>'sample');
my %REV_TARGET = ('sim'=>'SIM', sample=>'SAMPLE');

my ($name, $descr, $run, $parambox, @paramlist, $paramholder);
my $parammax = 0;


# ============== main code =============

pforms_gtk_init("Optikus Messaging");
Optikus::Watch::init(client_name => "opmsg",
                     server => $ENV{OPTIKUS_SERVER},
                     msg_dest => "sample",
                     conn_timeout => 0,
                     def_timeout => 1000,
                     period => 200,
                     verbosity => 1,
                    );
my $win = Gtk2::Window->new("toplevel");
$win->show;
read_cmsg_files();

if (open(F, $param_hash_file)) {
  my $hash_script = join("", (<F>));
  close F;
  eval $hash_script;
}

my $nb = Gtk2::Notebook->new;
$win->add($nb);
$nb->set_tab_pos("top");
$nb->append_page(create_cmsg_page(), " Control Messages ");

$win->signal_connect("delete_event" => \&Exit);
$win->signal_connect("destroy"      => \&Exit);
$win->set_default_size(900, 600);
$run->can_default(1);
$run->grab_default();

$win->show_all;
Optikus::Canvas::Util::set_window_icon($win, "tools/nav.png");

$cmsg_tree->signal_connect(cursor_changed => \&select_cmsg);
$cmsg_tree->signal_connect(key_press_event => \&process_keypress);

for (@paramlist) {
  $_->[0]->set_text("");
  $_->[1]->set_text("");
  $_->[0]->hide();
  $_->[1]->hide();
}

Gtk2->main;


# ====================== Control Messages ======================

sub read_cmsg_files
{
  open(INIT, "$cmsg_list_file") or croak "cannot read $cmsg_list_file\n";
  binmode(INIT, ":encoding(utf8)");
  my $init_script = join("", (<INIT>));
  close(INIT);
  eval $init_script;
  
  @cmsg = sort {
    $b->{target} cmp $a->{target} ||
	$a->{prognum} <=> $b->{prognum} ||
	$a->{datanum} <=> $b->{datanum}
  } @cmsg;
  
  for my $x (@cmsg) {
    my $target = $TARGET{$x->{target}};
    $cmsg_hash{$target}{$x->{prognum}}{$x->{datanum}} =
	[$x->{name}, $x->{descr}, $x->{param}];
  }
  foreach (keys %cmsg_class) {
    $cmsg_class{$TARGET{$_}} = $cmsg_class{$_};
  }
}


sub create_cmsg_chooser
{
  $cmsg_model = Gtk2::TreeStore->new(qw[ Glib::String Glib::String
                                     Glib::String Glib::String
                                     Glib::Scalar ]);
  my ($target, $func, $data);

  foreach $target (reverse keys %cmsg_hash) {
    my $starget = $REV_TARGET{$target};
    $starget = $target unless defined $starget;
    my $tnode = $cmsg_model->append (undef);
    $cmsg_model->set($tnode, 0, $starget);
    foreach $func (sort {$a <=> $b} keys %{$cmsg_hash{$target}}) {
      my ($sysname, $descr) = ('','');
      my $combo = $cmsg_class{$target}->{$func};
      ($sysname, $descr) = ($1, $2)
        if (defined $combo and $combo =~ /(.*?) - (.*)/);
      my $fnode = $cmsg_model->append($tnode);
      $cmsg_model->set($fnode, 0, $starget, 1, $func,
                      2, "($sysname)", 3, $descr);
      foreach $data (sort {$a <=> $b} keys %{$cmsg_hash{$target}{$func}}) {
        my $dnode = $cmsg_model->append($fnode);
        $cmsg_model->set($dnode,
                         0, $starget, 1, $func, 2, $data,
                         3, $cmsg_hash{$target}{$func}{$data}->[0],
                         4, [$target, $func, $data]);
      }
    }
  }

  $cmsg_tree = Gtk2::TreeView->new($cmsg_model);
  $cmsg_tree->set_rules_hint(1);
  $cmsg_tree->get_selection->set_mode('single');
  $cmsg_tree->set_size_request(500, 300);

  my ($renderer, $col_offset, $column);
  my @titles = ("Target", "Class", "Type", "Description");
  for my $k (0 .. $#titles) {
    $renderer = Gtk2::CellRendererText->new;
    $renderer->set(xalign => 0.0);
    $col_offset = $cmsg_tree->insert_column_with_attributes 
                                  (-1, $titles[$k], $renderer, text => $k);
    $column = $cmsg_tree->get_column($col_offset - 1);
    $column->set_clickable(1);
  }

  my $sw = Gtk2::ScrolledWindow->new(undef, undef);
  $sw->set_policy('automatic', 'automatic');  
  $sw->add($cmsg_tree);
  return $sw;
}

sub create_parambox
{
  my $paramcnt = shift;
  return undef if $paramcnt == 0;
  return if defined $parambox;
  $paramcnt = 22;
  $parammax = $paramcnt if $parammax < $paramcnt;
  $parambox = Gtk2::VBox->new(0, 0);
  undef @paramlist;
  for (1 .. $paramcnt) {
    my $box = Gtk2::HBox->new(0, 0);
    my $label = Gtk2::Label->new;
    $label->set_justify('left');
    $label->show;
    my $entry = Gtk2::Entry->new;
    $entry->show;
    $box->pack_start($label, 0, 0, 0);
    $box->pack_end($entry, 1, 1, 0);
    $parambox->pack_start($box, 0, 1, 0);
    push @paramlist, ([$label, $entry]);
  }
  $parambox->show;
  return $parambox;
}

my $prev_param_cnt = undef;

sub select_parambox
{
  my $pcnt = shift;
  return if not defined $pcnt;
  $prev_param_cnt = 0 unless defined $prev_param_cnt;
  return if $prev_param_cnt == $pcnt;
  for ($pcnt .. $prev_param_cnt) {
    $paramlist[$_][0]->set_text("");
    $paramlist[$_][1]->set_text("");
    $paramlist[$_][1]->set_editable(0);
    $paramlist[$_][0]->hide();
    $paramlist[$_][1]->hide();
  }
  for ($prev_param_cnt .. $pcnt-1) {
    $paramlist[$_][1]->show();
    $paramlist[$_][0]->show();
    $paramlist[$_][1]->set_editable(1);
  }
  $prev_param_cnt = $pcnt;
  return;
}

my $paramref;


sub set_params
{
  my ($param) = @_;
  $paramref = $param;
  my @pval = ();
  if (defined $rparam{$target}{$func}{$data}) {
    @pval = @{$rparam{$target}{$func}{$data}};
    print "Defined! [@pval]\n";
  }
  for my $i (0 .. $#{$param}) {
    $paramlist[$i][0]
        ->set_text(sprintf("%02d : %s  ", $i,
                   $param_type{$param->[$i]->{fmt}}->{display}) );
    $paramlist[$i][1]->set_text(@pval > 0 ? $pval[$i] : "");
    $paramlist[$i][1]->set_editable(1);
    $paramlist[$i][1]->set_visibility(1);
  }
}


sub send_cmsg
{
  my ($parambuf, $param);
  my @cache = ();
  my @vals = ();
  my $format = "";
  for my $i (0 .. $#{$paramref}) {
    my $entry = $paramlist[$i][1];
    my $text = $entry->get_text;
    my $value = eval($text);
    unless (defined $value) {
      $entry->grab_focus;
      run_dialog("ERROR",
                 "Please re-enter the ${i}-th argument", sub{},
                 "pic(kpic/button_cancel.png)OK");
      return;
    }
    my $fmt = $paramref->[$i]->{fmt};
    my $pattern = $param_type{$fmt}->{pattern};
    unless (defined $pattern and length($pattern) > 0) {
      run_dialog("ERROR",
                 "Invalid format \"$fmt\" of argument $i", sub{},
                 "pic(kpic/button_cancel.png)OK");
      return;
    }
    push @cache, $text;
    push @vals, $value;
    $format .= $pattern;
  }
  $rparam{$target}{$func}{$data} = [ @cache ]  if $#cache >= 0;
  Optikus::Watch::sendCtlMsg($target, $func, $data, $format, @vals);
}

sub create_cmsg_descr
{
  my ($vbox, $hbox, $hbbox, $scroll, $tview, $frame, $pane);

  $vbox = Gtk2::VBox->new(0, 0);
  $name = Gtk2::Label->new;
  $vbox->pack_start($name, 0, 1, 10);

  $hbox = Gtk2::HBox->new(0, 0);
  $frame = Gtk2::Frame->new("Description");
  $hbox->pack_end($frame, 1, 1, 0);
  $descr = Gtk2::TextBuffer->new(undef);
  $tview = Gtk2::TextView->new_with_buffer($descr);
  $tview->set_editable(0);
  $scroll = Gtk2::ScrolledWindow->new(undef, undef);
  $scroll->add($tview);
  $scroll->set_policy("automatic", "automatic");
  $scroll->set_shadow_type('in');
  $scroll->set_size_request(450, 220);
  $frame->add($scroll);

  $paramholder = Gtk2::ScrolledWindow->new(undef, undef);
  $paramholder->set_policy('automatic', 'automatic');
  $paramholder->set_border_width(0);
  $paramholder->set_size_request(280, 160);
  $paramholder->add_with_viewport(create_parambox(22));

  $pane = Gtk2::VPaned->new;
  $pane->add1($hbox);
  $pane->add2($paramholder);
  $vbox->pack_start($pane, 1, 1, 0);

  $hbbox = Gtk2::HBox->new(1, 5);
  $vbox->pack_end($hbbox, 0, 1, 5);
  $run = create_hor_button("pic(kpic/mail_send.png)Send");
  $run->signal_connect(clicked => \&send_cmsg);
  $hbbox->pack_start(Gtk2::Label->new(""), 1, 1, 1);
  $hbbox->pack_start($run, 0, 0, 0);
  $hbbox->pack_start(Gtk2::Label->new(""), 1, 1, 1);
  $run->set_sensitive(0);
  $vbox->show_all;
  return $vbox;
}

sub create_cmsg_page
{
  my ($page, $cmsg_chooser, $cmsg_descr, $label_box, $menu_label);
  $page = Gtk2::HPaned->new;
  $cmsg_descr   = create_cmsg_descr();
  $cmsg_chooser = create_cmsg_chooser();
  $page->add1($cmsg_chooser);
  $page->add2($cmsg_descr);
  $page->show_all;
  return $page;
}

sub select_cmsg
{
  my ($path, $column) = $cmsg_tree->get_cursor;
  my $iter = $cmsg_model->get_iter($path);
  my $dref = $cmsg_model->get($iter, 4);
  unless (defined($dref) && ref($dref) eq "ARRAY") {
    $run->set_sensitive(0);
    return;
  }
  ($target, $func, $data) = @$dref;
  unless (defined $target and defined $func and defined $data) {
    $run->set_sensitive(0);
    return;
  }
  display_cmsg($target, $func, $data);
}


sub process_keypress
{
  my ($tree, $event) = @_;
  my $kv = $event->keyval;
  return unless ($kv == 32 or $kv == 65293 or $kv == 65421);
  my ($path, $column) = $cmsg_tree->get_cursor;
  my $iter = $cmsg_model->get_iter($path);
  return unless defined($iter);
  $path = $cmsg_model->get_path($iter);
  return unless defined($path);
  $cmsg_tree->get_selection->select_path($path);
  if ($cmsg_tree->row_expanded($path)) {
    $cmsg_tree->collapse_row($path);
  } else {
    $cmsg_tree->expand_row($path, 0);
  }
}


sub display_cmsg
{
  my ($target, $func, $data) = @_;
  my $cmsg = $cmsg_hash{$target}{$func}{$data};
  $descr->set_text($cmsg->[1]) if defined $cmsg->[1];
  my $starget = $REV_TARGET{$target};
  $starget = $target unless defined $starget;
  $name->set_text("$starget - $func / $data $cmsg->[0]");
  $run->set_sensitive(1);
  select_parambox(scalar @{$cmsg->[2]});
  set_params($cmsg->[2]);
}

# ==================== Exit ===================

sub Exit
{
  if ($not_saved)
  {
    print "Saving parameters...";
    rename "$param_hash_file", "$param_hash_file.bak";
    open F, ">$param_hash_file" or die;
    $Data::Dumper::Indent = 1;
    $Data::Dumper::Purity = 1;
    print F Data::Dumper->Dump([\%rparam], ["*rparam"]);
    close F;
    print "OK\n";
    $not_saved = 0;
  }
  Gtk2->main_quit;
}
