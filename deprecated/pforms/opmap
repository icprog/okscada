#!/usr/bin/perl
# -*-perl-*-    vi: set ts=4 sw=4 :
#
#  Copyright (C) 2006-2007, vitki.net. All rights reserved.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  $Date$
#  $Revision$
#  $Source$
#
#  Interactive map.
#

use strict;
use FindBin qw[$Bin];
use Cwd 'abs_path';
BEGIN { $ENV{OPTIKUS_HOME} = abs_path("$Bin/..") unless $ENV{OPTIKUS_HOME}; }
use lib "$ENV{OPTIKUS_HOME}/lib/perl5/site_perl";

use utf8;
use Gtk2;
use Optikus::Forms::Util;
use Time::Local;
use Time::HiRes;
use Optikus::Watch;
use Optikus::Log ':all';

use constant BG        => "tiles/photo_800.jpg";
use constant STAR      => "controls/sputnik6.png";
use constant TRACEMAX  => 400;
use constant PI        => 3.14159265359;
use constant EPS       => 70;
use constant GPSepoch  => Time::Local::timegm(0, 0, 0, 6, 0, 1980);

my ($picture, $bgpixmap, $canvas, $dwin, $layout, %GC);
my ($ship_p, $ship_m, $ship_bs, $ship_gc, $ship_w, $ship_h);
my (@tracex, @tracey, @forex, @forey);
my ($map_y, $map_x, $map_h, $time, $map_time);

BEGIN
{
  for (my $i = 0; $i < TRACEMAX; $i++) { 
    $tracex[$i] = $tracey[$i] = 0;
  }
}

pforms_gtk_init("Optikus Map");
Optikus::Watch::init(client_name => "opmap",
                     server => $ENV{OPTIKUS_SERVER},
                     msg_dest => "sample",
                     conn_timeout => 500,
                     def_timeout => 1000,
                     period => 100,
                     verbosity => 2,
                    );
create_main_window();
$layout = Gtk2::Pango::Layout->new($picture->create_pango_context);
$layout->set_font_description(
                    Gtk2::Pango::FontDescription->from_string("Verdana 12"));
read_pixmaps();
tie $map_x,      "Optikus::Watch", 'map_x';
tie $map_y,      "Optikus::Watch", 'map_y';
tie $map_h,      "Optikus::Watch", 'map_h';
tie $map_time,   "Optikus::Watch", 'map_time';
Glib::Timeout->add(100, \&update_info);
Gtk2->main;


sub create_main_window
{
  my ($properties) = shift;
  my ($window, $vbox, $menu, $statusbox);
  $window = Gtk2::Window->new("toplevel");
  $window->signal_connect("destroy", sub { Gtk2->main_quit; });
  $window->show;
  Optikus::Forms::Util::set_window_icon($window, "kpic/fork.png");
  $vbox = Gtk2::VBox->new(0, 0);

  $picture = create_picture();
  $picture->show;
  $vbox->pack_start($picture, 0, 0, 0);
  $vbox->show;
  $window->add($vbox);
  $window->set_resizable(0);
  $dwin = $picture->window;
  $GC{normal} = $picture->style->fg_gc('normal');
  $GC{blue} = Gtk2::Gdk::GC->new($dwin);
  my $color = Gtk2::Gdk::Color->parse("#0000ff");
  $GC{blue}->get_colormap->alloc_color($color, 0, 0);
  $GC{blue}->set_foreground($color);
  $GC{white} = Gtk2::Gdk::GC->new($dwin);
  my $color = Gtk2::Gdk::Color->parse("#ffffff");
  $GC{white}->get_colormap->alloc_color($color, 0, 0);
  $GC{white}->set_foreground($color);
  $canvas = Gtk2::Gdk::Pixmap->new($dwin, 800,  400, -1);
  $canvas->draw_drawable($GC{normal}, $bgpixmap, 0, 0, 0, 0, 800, 400);
  $canvas->draw_pixbuf($GC{normal}, create_pic(BG),
                       0, 0, 0, 0, 800, 400, "none", 0, 0);
  $ship_gc = Gtk2::Gdk::GC->new($dwin);
  $ship_gc->set_clip_mask($ship_m);
}

sub vectorize
{
  my ($X, $Y) = @_;
  $X *= PI/400;
  $Y *= PI/400;
  $X -= PI;
  $Y *= -1;
  my $x = cos($X) * sin($Y);
  my $y = sin($X) * sin($Y);
  my $z = cos($Y);
  return [$x, $y, $z];
}


my %dig = ();

sub read_pixmaps
{
  my %pix = ('0'=>'0','1'=>'1','2'=>'2','3'=>'3','4'=>'4',
             '5'=>'5','6'=>'6','7'=>'7','8'=>'8','9'=>'9',
             "'"=>'apostrophe','"'=>'dblquote',
             '-'=>'dash',':'=>'colon',' '=>'space',
             '.'=>'dot',','=>'comma');
  for my $key (keys %pix) {
    my $image = create_pic("controls/cntr_$pix{$key}.png");
    $dig{$key} = $image->render_pixmap_and_mask(1);
  }
}

sub create_picture
{
  my ($darea, $bgimage, $ship_im, $w, $h);
  $darea = Gtk2::DrawingArea->new;
  $bgimage = create_pic(BG);
  ($w, $h) = ($bgimage->get_width, $bgimage->get_height);
  $darea->size($w, $h);
  $bgpixmap = $bgimage->render_pixmap_and_mask(1);
  $ship_im = create_pic(STAR);
  ($ship_w, $ship_h) = ($ship_im->get_width, $ship_im->get_height);
  ($ship_p, $ship_m) = $ship_im->render_pixmap_and_mask(1);
  $darea->signal_connect( 'expose_event', \&do_picture_expose );
  $darea->add_events([qw[exposure_mask]]);
  undef $bgimage;
  return $darea;
}

sub xform
{
  my ($x, $y) = @_;
  $x *= 400.0/180;
  $y *= 200.0/90;
  $x = 400 + $x;
  $y = 200 - $y;
  $x += 800 while $x < 0;
  $x -= 800 while $x >= 800;
  return ($x, $y);
}

my ($oldx, $oldy) = (0, 0);
my ($oldpx, $oldpy);
my $CUR = 0;

sub move_star
{
  my ($newx, $newy) = @_;
  my ($newpx, $newpy);
  $newx = int($newx + 0.5);
  $newy = int($newy + 0.5);
  $newpx = int($newx - $ship_w / 2);
  $newpy = int($newy - $ship_h / 2);
  return if $newx == $oldx and $newy == $oldy;
  if (defined $ship_bs) {
    $canvas->draw_drawable($GC{normal}, $ship_bs, 0, 0,
                           $oldpx, $oldpy, $ship_w, $ship_h);
    $dwin->draw_drawable($GC{normal}, $canvas, $oldpx, $oldpy,
                         $oldpx, $oldpy, $ship_w, $ship_h);
  } else {
    $ship_bs = Gtk2::Gdk::Pixmap->new($dwin, $ship_w, $ship_h, -1);
    $ship_gc = Gtk2::Gdk::GC->new($dwin);
    $ship_gc->set_clip_mask($ship_m);
  }
  ($oldx, $oldy) = ($newx, $newy);
  ($oldpx, $oldpy) = ($newpx, $newpy);
  $canvas->draw_point($GC{normal}, $newx, $newy);
  $CUR++;
  $CUR = 0 if $CUR >= TRACEMAX;
  if ($tracey[$CUR]) {
    $dwin->draw_drawable($GC{normal}, $bgpixmap,
                         $tracex[$CUR], $tracey[$CUR],
                         $tracex[$CUR], $tracey[$CUR],
                         1, 1);
    $canvas->draw_drawable($GC{normal}, $bgpixmap,
                           $tracex[$CUR], $tracey[$CUR],
                           $tracex[$CUR], $tracey[$CUR],
                           1, 1);
  }
  $tracex[$CUR] = int($newx);
  $tracey[$CUR] = int($newy);
  $ship_bs->draw_drawable($GC{normal}, $canvas, $newpx, $newpy,
                          0, 0, $ship_w, $ship_h);
  $ship_gc->set_clip_origin($newpx, $newpy);
  $canvas->draw_drawable($ship_gc, $ship_p, 0, 0,
                         $newpx, $newpy, $ship_w, $ship_h);
  $dwin->draw_drawable($GC{normal}, $canvas, $newpx, $newpy,
                       $newpx, $newpy, $ship_w, $ship_h);
  $oldx = $newx;
  $oldy = $newy;
  $oldpx = $newpx;
  $oldpy = $newpy;
}


my $i;
my ($px, $py);

sub update_star
{
  $i++;
  my ($x, $y, $r) = ($map_x, $map_y, $map_h);
  return 1 if (!defined($r) or $r < 100);
  return 1 if ($px == $x and $py == $y);
  move_star(xform($x, $y));
  ($px, $py) = ($x, $y);
}

my $ptime = 0;

sub draw_msg
{
  my ($x, $y, $s) = @_;
  for my $c (split('', $s)) {
    $dwin->draw_drawable($GC{normal}, $dig{$c}, 0, 0, $x, $y, 16, 16);
    $x += 16;
  }
  return $x;
}

sub update_info
{
  $time = $map_time;
  return 1 unless defined $time; # or $ltime == $ptime;

  my $btime = $time;
  my $ltime = time();

  update_star();
  my (@time);

  my $TZ = $ENV{TZ};
  my $n = 1;
  foreach ("CST6CDT", "GMT", $TZ)  {
    $ENV{TZ} = $_;
    @time = localtime($btime);
    draw_msg(240 - 16*8, 400 - 18*$n,
             sprintf("%02d:%02d:%02d", $time[2], $time[1], $time[0]));
    $n++;
  }
  $n = 1;
  foreach ("CST6CDT", "GMT", $TZ)  {
    $ENV{TZ} = $_;
    @time = localtime;
    draw_msg(424 - 16*8, 400 - 18*$n,
             sprintf("%02d:%02d:%02d", $time[2], $time[1], $time[0]));
    $n++;
  }
  $ENV{TZ} = $TZ;

  $n = 1;
  draw_msg(800 - 16*8, 400-18*$n, sprintf(" %6.3f", $map_h));

  $n = 2;
  for my $val ($map_x, $map_y) {
    my $vc = int($val);
    my $vd = $val - $vc;
    my $g = int($vd * 60);
    my $str = $val < 0 ? sprintf("%04d:%02d'", $vc, -$g)
                       : sprintf(" %03d:%02d'", $vc, $g);
    draw_msg(800 - 16*8, 400-18*$n, $str);
    $n++;
  }
  $ptime = $ltime;
  return 1;
}

sub do_picture_expose
{
  my ($widget, $event) = @_;
  my $area = $event->area;
  $dwin->draw_drawable($GC{normal}, $canvas,
                       $area->x, $area->y,
                       $area->x, $area->y,
                       $area->width, $area->height);
  for (my $i = 0; $i < @forex; $i++) {
    $dwin->draw_point($GC{white}, $forex[$i], $forey[$i]);
  }
  return 0;
}
